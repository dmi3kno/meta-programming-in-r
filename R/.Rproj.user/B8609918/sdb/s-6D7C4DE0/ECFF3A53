{
    "collab_server" : "",
    "contents" : "\nmodulus <- R6Class(\"modulus\", \n                    private = list(\n                      value_ = c(),\n                      n_ = c()\n                    ),\n                   public = list(\n                     initialize = function(value, n) {\n                       private$value_ <- value\n                       private$n_ <- n\n                     },\n                     print = function() {\n                       cat(\"Modulus\", private$n_, \"values:\\n\")\n                       print(private$value_)\n                     }\n                   ),\n                   active = list(\n                     value = function(value) {\n                       if (missing(value)) private$value_\n                       else private$value_ <- value %% private$n_\n                     },\n                     n = function(value) {\n                       if (!missing(value)) stop(\"Cannot change n\")\n                       private$n_\n                     }\n                   ))\n\n(x <- modulus$new(value = 1:6, n = 3))\n\nOps.modulus <- function(e1, e2) {\n  nx <- ny <- NULL\n  if (inherits(e1, \"modulus\")) nx <- e1$n\n  if (inherits(e2, \"modulus\")) ny <- e2$n\n  if (!is.null(nx) && !is.null(ny) && nx != ny)\n    stop(\"Incompatible types\")\n  n <- ifelse(!is.null(nx), nx, ny)\n  \n  v1 <- e1\n  v2 <- e2\n  if (inherits(e1, \"modulus\")) v1 <- e1$value\n  if (inherits(e2, \"modulus\")) v2 <- e2$value\n  \n  e1 <- v1 ; e2 <- v2\n  result <- NextMethod() %% n\n  modulus$new(result, n)\n}\n\nx + 1:6\n1:6 + x\n2 * x\n\ny <- modulus$new(value = 1:2, n = 3)\nx + y\n\n\nmodulus2 <- R6Class(\"modulus2\", inherit = modulus)\ny <- modulus2$new(value = 1:2, n = 3)\n\nx + y\n\nclass(y)\n\n\n\nsetOldClass(\"modulus\")\nsetGeneric(\"f\", def = function(e1,e2) standardGeneric(\"f\"))\nsetMethod(\"f\", signature = c(\"modulus\", \"modulus\"),\n          definition = function(e1, e2) {\n            return(\"foo?\")\n            if (e1@n != e2@n) stop(\"Incompatible modulus\")\n            modulus(value = e1@value + e2@value,\n                    n = e1@n)\n          })\n\nsetMethod(\"+\", signature = c(\"modulus\", \"modulus\"),\n          definition = function(e1, e2) {\n            return(\"foo?\")\n            if (e1@n != e2@n) stop(\"Incompatible modulus\")\n            modulus(value = e1@value + e2@value,\n                    n = e1@n)\n          })\n\nf(x, y)\nx + y\n",
    "created" : 1483724132557.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2329048476",
    "id" : "ECFF3A53",
    "lastKnownWriteTime" : 1483732909,
    "last_content_update" : 1483732909842,
    "path" : "~/Dropbox/Misc. writing/Books/Advanced Statistical Programming in R/Object Oriented Programming in R/R/r6modulus.R",
    "project_path" : "r6modulus.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}